/* Generated by Together */

package uk.ac.stand.dcs.asa.jchord.impl;

import uk.ac.stand.dcs.asa.eventModel.Event;
import uk.ac.stand.dcs.asa.eventModel.eventBus.busInterfaces.EventBus;
import uk.ac.stand.dcs.asa.interfaces.IKey;
import uk.ac.stand.dcs.asa.jchord.events.JChordEventFactory;
import uk.ac.stand.dcs.asa.jchord.interfaces.IJChordNode;
import uk.ac.stand.dcs.asa.jchord.interfaces.IJChordRemote;
import uk.ac.stand.dcs.asa.util.Diagnostic;
import uk.ac.stand.dcs.asa.util.Error;

import java.util.ArrayList;
import java.util.Iterator;

/**
 * 
 * @author stuart
 */
public class SuccessorList {

    /* configuration - constants */
    // TODO general mechanism for exposing and controlling configuration parameters.
    public static int MAX_SIZE = 5;
    
    /* fields */
    private IJChordNode local_node;
    private EventBus bus;
    private ArrayList store;
    
    /* constructors */
    public SuccessorList(IJChordNode local_node, EventBus bus) {
        this.local_node=local_node;
        this.bus=bus;
        store=new ArrayList();
    }

    /* methods */
    /**
     * Searches the successor list for a working node.
     * 
     * @return the first working node in the SuccessorList, or null if there are none
     */
    public IJChordRemote findFirstWorkingNode() {
        
        for (Iterator i = store.iterator(); i.hasNext();) {
            IJChordRemote next = (IJChordRemote) i.next();
            try {
                next.isAlive();
                return next;
            }
            catch (Exception e) {/* ignore error */}
        }
        return null;
    }

    /**
     * @return the size of the successor list
     */
    public int size() {
        return store.size();
    }

    /**
     * @return the successor list
     */
    public Object[] getListAsArray() {
        return store.toArray();
    }

    /**
     * This constructs a new successor list which consists of this node's
     * successor followed by the first (MAX_SIZE-1) elements of the successor's
     * successor list.
     */
    public void refreshList(Object[] new_list, IJChordRemote successor) {
        ArrayList added=null;
        ArrayList removed=null;
        ArrayList newList=null;
        
        if(successor==local_node){
            /*
             * This is a new ring or we have collapsed back to a single node.
             */
            if(store.size()!=0){
                /*
                 * The successor list is not empty.
                 */
                removed=store;
                newList=new ArrayList();
            }
        }else{
        
            newList = new ArrayList();
            
            // TODO change this code once we are sure that rafda is sending ArrayLists by value
            int numElements;
            
            if (new_list.length >= MAX_SIZE) numElements = MAX_SIZE - 1;
            else numElements = new_list.length;
        
            // Check for the element of the successor list being this node, as will
            // happen with a small number of nodes in the ring. If this node is
            // found in the recieved successor list then that element and all
            // elements following it are discarded.
    
            for(int i=0;i<numElements;i++){
                IJChordRemote node = (IJChordRemote) new_list[i];
                if(node.getKey().compareTo(local_node.getKey())==0){
                    break;
                }else{
                    newList.add(node);
                }
            }        
            newList.add(0, successor);
            
            added = addedNodes(store, newList);
            removed = removedNodes(store, newList);
        }
        if (added != null || removed != null) {
            Diagnostic.trace("Old SuccessorList: " + listAsKeyString(store));
            store = newList;            
            Diagnostic.trace("New SuccessorList: " + listAsKeyString(store));
            Diagnostic.trace("added: " + listAsKeyString(added));
            Diagnostic.trace("removed: " + listAsKeyString(removed));

            KeyRange keyRange = null;
            IJChordRemote pred = null;
            try {
                pred = local_node.getPredecessor();
            } catch (Exception e) {
                Error.hardError("local call to getPredecessor failed");
            }
            /*
             * This node's predecessor may be null.
             */
            if (pred != null) {
                IKey pred_key = pred.getKey();
                keyRange = KeyRange.makeClosedRangeFromHalfOpen_includeUpper(
                        pred_key, local_node.getKey());

            }
            /*
             * If pred is null then we cannot workout the key range for the
             * local node. Here we generate the event regardless of whether or
             * not we know the local key range.
             */
            Event e = JChordEventFactory.makeSuccessorListChangeEvent(store,
                    keyRange, newList, added, removed);
            bus.publishEvent(e);
        }
        
    }
   
    /**
     * Compute the set of nodes that are in the sucessor list recieved form this
     * node's successor and which are not this node's current successor list.
     * 
     * @param currentList
     *            this entries (in ring order) in this nodes current
     *            SuccessorList
     * @param newList
     *            the SuccessorList entries (in ring order) recieved from this
     *            node's successor which does not contain this node's successor.
     *            We assume that this node's successor has been added to the
     *            start of the list.
     */
    private ArrayList addedNodes(ArrayList currentList, ArrayList newList){
        /*
         * For each node in newList, if the node is not
         * in currentList, add the node to added.
         */
        ArrayList added=null;
        //TODO can newList be null?
        if(newList!=null){
            Iterator i=newList.iterator();
            while(i.hasNext()){
                IJChordRemote node=(IJChordRemote)i.next();
                if(!containsNode(currentList,node)){
                    if(added==null){
                        added=new ArrayList();
                    }
                    added.add(node);
                }
            }
        }
        return added;
    }
    
    /**
     * Compute the set of nodes that are in this node's current sucessor list
     * and which are not in the successor list recieved form this node's
     * successor.
     * 
     * @param currentList
     *            this entries (in ring order) in this nodes current
     *            SuccessorList
     * @param newList
     *            the SuccessorList entries (in ring order) recieved from this
     *            node's successor which does not contain this node's successor.
     *            We assume that this node's successor has been added to the
     *            start of the list.
     */
    private ArrayList removedNodes(ArrayList currentList, ArrayList newList){
        /*
         * For each node in currentList, if the node is not
         * in newList, add the node to removed.
         */
        ArrayList removed=null;
        if(currentList!=null){
            Iterator i=currentList.iterator();
            while(i.hasNext()){
                IJChordRemote node=(IJChordRemote)i.next();
                if(!containsNode(newList,node)){
                    if(removed==null){
                        removed=new ArrayList();
                    }
                    removed.add(node);
                }
            }
        }
        return removed;
    }
    
    private boolean containsNode(ArrayList list, IJChordRemote node) {
        //TODO write more efficient algorithms.
        if(list!=null){
            Iterator i=list.iterator();
            while(i.hasNext()) {
                IJChordRemote ln=(IJChordRemote)i.next();
                if(ln.getKey().compareTo(node.getKey())==0)return true;
            }
        }
        return false;
    }

    public String listAsKeyString(ArrayList list){
        String listStr = "";
        if(list!=null){
            Iterator i = list.iterator();
            int element=0;
            while(i.hasNext()){
                if(element++!=0)listStr+=" : ";
                IJChordRemote node = (IJChordRemote)i.next();
                listStr+=node.getKey().toString();
            }
        }
        return listStr;
    }
    
    public ArrayList getList() {
        return store;
    }

    public IJChordRemote getLocalNode() {
        return local_node;
    }

    // Needed by custom serializer.
    // TODO should set local_node?
    public void setLocalNode(IJChordRemote remote) {
        // Empty.
    }
    
    // Needed by custom serializer.
    // TODO should set store?
    public void setStore(ArrayList list){
        // Empty.
    }
}